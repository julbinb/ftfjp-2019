We set out to define semantic subtyping that can be useful in the context
of dynamic languages, however, 
the semantic definition we presented
appears to have an undesired implication for dynamic dispatch.
%it appears that the semantic definition we presented
%has an undesired implication for dynamic dispatch.
In this section, using multiple dispatch as a running example,
we discuss the implication and suggest a solution.
%In this section, we describe in more detail how subtyping
%can be used to implement multiple dynamic dispatch,
%and also discuss implications of using \emph{semantic} subtyping.

Consider the following methods\footnote{In the context of MD, 
	different implementations of 
	the same function are usually called \emph{methods},
	and the set of all methods a \emph{generic function}.}
of the addition function defined in the Julia syntax
(we assume that function \jlcode{flt} converts its argument to a float):
\begin{lstminijl}
+(x::Int, y::Int) = prim_add_int(x, y) 
+(x::Flt, y::Flt) = prim_add_flt(x, y) 
+(x::Int%*$\cup$*)Flt, y::Int%*$\cup$*)Flt) = prim_add_flt(flt(x), ..)
\end{lstminijl}
and the function call \jlcode{3 + 5}.
How exactly does dispatch work?

One approach, adopted by some languages
such as Julia~\cite{Bezanson2015AbstractionIT}, 
is to use subtyping on tuple types~\cite{bib:Leavens:1998:mddtuples}.
Namely, method signatures and function calls are interpreted as tuple types,
and then subtyping is used to determine applicable methods 
as well as pick one of them.
In the example above, the three methods are interpreted 
as the following types (from top to bottom):\\
\jlcode{mII $\equiv$ Int $\times$ Int}\\
\jlcode{mFF $\equiv$ Flt $\times$ Flt}\\
\jlcode{mUU $\equiv$ (Int$\cup$Flt) $\times$ (Int$\cup$Flt)}\\
and the call as having type \jlcode{cII $\equiv$ Int $\times$ Int}.
To resolve the call, the language run-time ought to perform two steps.
\begin{enumerate}
  \item Find the applicable methods (or raise an error if there are none). 
    For this, subtyping is checked between
    the type of the call, \jlcode{cII}, and the method signatures.
    Since \jlcode{cII $<:$ mII} and \jlcode{cII $<:$ mUU} but
    \jlcode{cII $\not{<:}$ mFF}, only two methods are applicable,
    \jlcode{mII} for integers and \jlcode{mUU} for mixed-type numbers.
  \item Pick the most specific of the applicable methods
    (or raise an error if there is an ambiguity).
    For this, all the applicable methods are compared pairwise using subtyping.
    In this example, naturally, we would like \jlcode{mII} to be called
    for the addition of integers. And indeed, since \jlcode{mII $<:$ mUU},
    the integer addition is considered the most specific.
\end{enumerate}
Additionally, consider the call \jlcode{3.14 + 5}. Its type is
\jlcode{Flt $\times$ Int}, and there is only one applicable method \jlcode{mUU}
that is a supertype of the call type, so it should be called.

%It is important to understand 
What happens if the programmer defines
several implementations with the same argument types? 
In the case of a static language, an error can be reported.
In the case of a dynamic language, however, the second implementation
simply replaces the earlier one in the same way as reassignment
to a variable replaces its previous value.

For instance, consider a program 
that contains the three previous implementations of \jlcode{(+)} %from above
and also: % the following:
\begin{lstminijl}
+(x::Real, y::Real) = ...   # mRR
print(3.14 + 5)	 
\end{lstminijl}
According to the semantic subtyping relation, type \jltype{Real} is equivalent
to \jltype{Int$\cup$Flt} in \BetaJulia. 
Therefore, the implementation of \jlcode{mRR} will replace 
\jlcode{mUU} defined earlier, 
and the call \jlcode{3.14 + 5} will be dispatched to \jlcode{mRR}.

There is a problem: %due to the use of semantic subtyping, 
the semantics of the program above will change
%There is a problem with using semantic subtyping for MD:
%the semantics of the program above is not stable.
if the programmer adds a new subtype of \jltype{Real} 
into the nominal hierarchy.
For instance, if they add \jlcode{Int8 $<:$ Real}, type \jlcode{Real}
becomes equivalent to \jltype{Int$\cup$Flt$\cup$Int8} 
instead of \jltype{Int$\cup$Flt}.
Therefore, if the program is re-run, the type of \jlcode{mUU} 
will be a strict subtype of \jlcode{mRR},
so the implementation of \jlcode{mRR} will not replace \jlcode{mUU}. 
%Since \jlcode{mUU $<:$ mRR}, 
Therefore, the call \jlcode{3.14 + 5} 
will be dispatched to \jlcode{mUU}, not \jlcode{mRR}. %as before.

We can gain stability by removing the rules that 
equate abstract nominal types with the union of their subtypes,
i.e. \RD{RealUnion} and \RD{NumUnion} in the declarative definition.\footnote{
    To get an equivalent reductive subtyping, we need to change 
    the \RR{NF} rule: replace normalization function $\NF$ with $\NFAt$ 
    (\figref{fig:bjnom-calc-nf-full}, \appref{app:nf}).}
To fix the discrepancy between this definition and the semantic interpretation,
we can change the latter by accounting for potential extension
of the nominal hierarchy, %``future nominal types'':
%e.g. $\interpty{\tyreal} = \{\tyint, \tyflt, X\}$.
\[
\begin{array}{rcl}
\interpty{\tyreal} & = & \{ \tyint, \tyflt, E_{\tyreal} \} \\
\interpty{\tynum} & = & \{ \tyint, \tyflt, \tycmplx,
                           E_{\tyreal}, E_{\tynum} \},
\end{array}
\]
where $E_\aname$ denotes some concrete nominal type extending \aname.
This alternative interpretation captures the intuition
that a method with an argument of type \aname should behave
regardless of what subtypes of \aname are present in the nominal hierarchy.
When a programmer defines such a method, they anticipates 
that the hierarchy can be extended.
%It needs to be understood whether such an interpretation provides us with
%a useful intuition about subtyping.


%MD allows to have several implementations of the same function,
%with the best implementation for a particular call being picked 
%at run-time based on the types of the arguments.
%As an example, consider two implementations of shape intersection
%(implementations are usually called \emph{methods}):
%\begin{verbatim}
%intersect(r1::Rectangle, r2::Rectangle) = ...
%intersect(s1::Shape, s2::Shape) = ...
%\end{verbatim}
%and two function calls, \jlcode{intersect(Circle(..), Circle(..))}
%and \jlcode{intersect(Rectangle(..), Rectangle(..))},
%assuming that \jltype{Circle} is a subtype of \jltype{Shape}.
%The method signatures can be interpreted as tuple types
%\jltype{mRR $\equiv$ Rectangle $\times$ Rectangle} 
%and \jltype{mSS $\equiv$ Shape $\times$ Shape},
%and the function calls~--- as tuple types 
%\jltype{CC $\equiv$ Circle $\times$ Circle} 
%and \jltype{RR $\equiv$ Rectangle $\times$ Rectangle}.
%To resolve the calls, language run-time needs to perform two steps.
%(1) Determine which methods are applicable to the given arguments (if any)
%by checking subtyping between the call and the signatures.
%Since \jlcode{CC} is a subtype of \jlcode{mSS} but not of  \jlcode{mRR}, 
%only shape intersection
%is applicable to the circle call, so it should be called.
%Since \jlcode{RR} is a subtype of  \jlcode{mSS} and  \jlcode{mRR}, 
%both intersection methods 
%are applicable to the rectangle call, so we go to the next step.
%(2) Pick the best of all the applicable methods (if there is one) 
%by checking subtyping between their signatures.
%Since  \jlcode{mRR} is a subtype of  \jlcode{mSS} but not vice versa, 
%it is considered to be
%the most specific method applicable to  \jlcode{RR}, 
%and so the rectangle call is dispatched to the rectangle intersection.