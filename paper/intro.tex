Many static type systems rely on subtyping.
Informally, subtyping relation \jltype{T $<:$ S} states that it is safe
to use a value of type~\jltype{T} in the context that expects~\jltype{S}.
For instance, if class \jltype{Rectangle} is subtype of \jltype{Shape},
an instance of \jltype{Rectangle} can be used where a \jltype{Shape}
is expected.

In languages with nominal typing, subtyping can also be used for run-time
dispatch, in particular, multiple dynamic dispatch (MDD).
With MDD, one can provide several implementations of the same function,
and the ``best'' implementation for a particular call will be picked 
at run-time based on the \emph{type tags} of the arguments.
For example, consider two implementations of shape intersection,
\jlcode{intersect(Rectangle, Rectangle)} and \jlcode{intersect(Shape, Shape)}.
If we want to intersect two circles (assuming that \jltype{Circle}
is subtype of \jltype{Shape}), only the latter implementation can be applied,
and so it should be called.
However, if we want to intersect two rectangles, both implementations 
are applicable, and, intuitively, the former is better, 
so \jlcode{intersect(Rectangle, Rectangle)} should be called.
There are various approaches to formally 
defining applicable methods and selecting the best. 
One way is to use \emph{subtyping}~\cite{?}.
In this case, method signatures and function calls are looked at 
as tuple types, applicable methods are defined as supertypes of the call type, 
and the best method must be subtype of other applicable methods. 
Thus, for the example above, method signatures are 
\jltype{Rectangle $\times$ Rectangle} (RR) 
and \jltype{Shape $\times$ Shape} (SS),
and function calls are
\jltype{Circle $\times$ Circle} and \jltype{Rectangle $\times$ Rectangle}.
The \jltype{Circle} tuple type is not subtype of RR,
but it is subtype of SS, so only shape intersection
is applicable in the circle call.
The \jltype{Rectangle} tuple type is subtype of both RR and SS, 
so both implementations are applicable.
Since RR is subtype of SS, the RR implementation is considered the best one.

Multiple dynamic dispatch does not 

\defemph{NO TRESPASSING}

It is often convenient to think of subtyping in terms of the set inclusion:
type \jltype{T} is subtype of \jltype{S} if ``the elements of~\jltype{T}
are the subset of the elements of~\jltype{S}''~[TAPL].
Though this intuition is not always correct, there have been research on
\emph{semantic subtyping}~\cite{??} that does define subtyping as the subset
relation.






Two flavors of subtyping: syntactic and semantic. 

Semantic subtyping enables simple set-theoretic reasoning about types
in terms of values they represent.
Because of that, it is especially appealing to the users of a language.
However, semantic subtyping might be problematic for the language designers:
defining the interpretation of types and developing a corresponding
sound and complete subtyping algorithm is usually quite tricky.

Prior work on semantic subtyping was mostly focused on rather complex languages
with structural types (XML-CDuce or Object-Oriented Ancona).
For example, \ldots. Often care about static typing.

In this work, we explore the applicability of semantic subtyping in the context
of a \emph{dynamic language with nominal types} 
where all \emph{values are type tagged}. 
This allows us to considerably simplify the traditional notion 
of semantic subtyping.
Namely, we interpret a type as a set of type tags, 
with a tag faithfully characterizing a set of values.

We draw our inspiration from the dynamically typed language Julia,
which employs nominal types in a peculiar fashion. For performance reasons, 
only leaf types in the hierarchy of nominal types
can be used to construct values.
As an example, consider two types, \jltype{Int64} and \jltype{Signed}:
\jltype{Int64} is a leaf type, 
and \jltype{Signed} is its declared supertype.
Any 64-bit machine integer value is tagged with the type \jltype{Int64}
and considered to be of type \jltype{Int64}.
Such a value is also considered to be of type \jltype{Signed},
but \emph{no values are tagged} with \jltype{Signed}.
Thus, we can give the semantic interpretation of \jltype{Signed}
solely in terms of its leaf subtypes:
\[
\interpty{\tysigned} = \{\tyintsf, \tyinttt, \tyintst, \ldots\}.
\]

Our contributions are as follows:
\begin{itemize}
  \item semantic interpretation of nominal types for a Julia-like 
    dynamic language (\secref{todo});
  \item simple syntactic model of semantic subtyping for nominal types,
    covariant pairs, and untagged unions (\secref{todo});
  \item decidable reductive subtyping provably equivalent to \ldots (\secref{todo});
  \item discussion of the applicability of semantic subtyping to Julia (\secref{todo}).
  \item Coq!
\end{itemize}

\TODO{Note that Julia uses those types for multiple dynamic dispatch}

%Besides nominal types, we take covariant pairs and untagged unions.

%That is, any value of type \jltype{Signed} 
%is tagged with one of its leaf subtypes,
%and we can characterize the set of values represented by the type 
%solely in terms of the leaf types.
%Because of that, the type \jltype{Signed} can be interpreted in terms
%of its leaf subtypes.

%The designers of Julia, in turn, were inspired
%by the work on semantic subtyping~\citemock.
%In Julia, all values have type tags that never change at run-time.
%Therefore, tags faithfully characterize sets of values.
%Julia uses subtyping extensively for multiple dynamic dispatch. 






