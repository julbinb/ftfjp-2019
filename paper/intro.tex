Many static type systems rely on subtyping.
Informally, subtyping relation \jltype{T $<:$ S} states that it is safe
to use a value of type~\jltype{T} in the context that expects~\jltype{S}.
For instance, if class \jltype{Rectangle} is subtype of \jltype{Shape},
an instance of \jltype{Rectangle} can be used where a \jltype{Shape}
is expected.

In languages with nominal typing, subtyping can also be used for run-time
dispatch, in particular, multiple dynamic dispatch (MDD).
With MDD, one can provide several implementations of the same function,
and the ``best'' implementation for a particular call will be picked 
at run-time based on the types of the arguments.
For example, consider two implementations of shape intersection,
\jlcode{intersect(Rectangle, Rectangle)} and \jlcode{intersect(Shape, Shape)}.
If we want to intersect two circles (assuming that \jltype{Circle}
is subtype of \jltype{Shape}), only the latter implementation can be applied,
and so it should be called.
However, if we want to intersect two rectangles, both implementations 
are applicable, and, intuitively, the former is better, 
so \jlcode{intersect(Rectangle, Rectangle)} should be called.
There are various approaches to defining applicable methods and selecting
the best. One way is to use \emph{subtyping}~\cite{?}.
In this case, method signatures and function calls are looked at 
as tuple types, applicable methods are defined as supertypes of a call, 
and the best method must be subtype of other applicable methods. 
Thus, for the example above, method signatures are 
\jltype{Rectangle $\times$ Rectangle} and \jltype{Shape $\times$ Shape},
and function calls are
\jltype{Circle $\times$ Circle} and \jltype{Rectangle $\times$ Rectangle}.
The \jltype{Circle} tuple is not subtype of the \jltype{Rectangle} tuple, 
but it is subtype of the \jltype{Shape} tuple, so only shape intersection
is applicable in the circle call.


\defemph{NO TRESPASSING}

It is often convenient to think of subtyping in terms of the set inclusion:
type \jltype{T} is subtype of \jltype{S} if ``the elements of~\jltype{T}
are the subset of the elements of~\jltype{S}''~[TAPL].
Though this intuition is not always correct, there have been research on
\emph{semantic subtyping}~\cite{??} that does define subtyping as the subset
relation.

Though this intuition is not always correct, it might be a useful reasoning tool
for the users of a programming language.
Such an intuition is not always correct, but there
There have been the whole line of work 




Subtyping \ldots (roughly what it is; is used both in static and dynamic
languages).

Two flavors of subtyping: syntactic and semantic. 

Semantic subtyping enables simple set-theoretic reasoning about types
in terms of values they represent.
Because of that, it is especially appealing to the users of a language.
However, semantic subtyping might be problematic for the language designers:
defining the interpretation of types and developing a corresponding
sound and complete subtyping algorithm is usually quite tricky.

Prior work on semantic subtyping was mostly focused on rather complex languages
with structural types (XML-CDuce or Object-Oriented Ancona).
For example, \ldots. Often care about static typing.

In this work, we explore the applicability of semantic subtyping in the context
of a \emph{dynamic language with nominal types} 
where all \emph{values are type tagged}. 
This allows us to considerably simplify the traditional notion 
of semantic subtyping.
Namely, we interpret a type as a set of type tags, 
with a tag faithfully characterizing a set of values.

We draw our inspiration from the dynamically typed language Julia,
which employs nominal types in a peculiar fashion. For performance reasons, 
only leaf types in the hierarchy of nominal types
can be used to construct values.
As an example, consider two types, \jltype{Int64} and \jltype{Signed}:
\jltype{Int64} is a leaf type, 
and \jltype{Signed} is its declared supertype.
Any 64-bit machine integer value is tagged with the type \jltype{Int64}
and considered to be of type \jltype{Int64}.
Such a value is also considered to be of type \jltype{Signed},
but \emph{no values are tagged} with \jltype{Signed}.
Thus, we can give the semantic interpretation of \jltype{Signed}
solely in terms of its leaf subtypes:
\[
\interpty{\tysigned} = \{\tyintsf, \tyinttt, \tyintst, \ldots\}.
\]

Our contributions are as follows:
\begin{itemize}
  \item semantic interpretation of nominal types for a Julia-like 
    dynamic language (\secref{todo});
  \item simple syntactic model of semantic subtyping for nominal types,
    covariant pairs, and untagged unions (\secref{todo});
  \item decidable reductive subtyping provably equivalent to \ldots (\secref{todo});
  \item discussion of the applicability of semantic subtyping to Julia (\secref{todo}).
  \item Coq!
\end{itemize}

\TODO{Note that Julia uses those types for multiple dynamic dispatch}

%Besides nominal types, we take covariant pairs and untagged unions.

%That is, any value of type \jltype{Signed} 
%is tagged with one of its leaf subtypes,
%and we can characterize the set of values represented by the type 
%solely in terms of the leaf types.
%Because of that, the type \jltype{Signed} can be interpreted in terms
%of its leaf subtypes.

%The designers of Julia, in turn, were inspired
%by the work on semantic subtyping~\citemock.
%In Julia, all values have type tags that never change at run-time.
%Therefore, tags faithfully characterize sets of values.
%Julia uses subtyping extensively for multiple dynamic dispatch. 






