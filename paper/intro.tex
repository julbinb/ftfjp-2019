Many static type systems rely on subtyping.
Informally, subtyping relation \jltype{T $<:$ S} states that
a value of type~\jltype{T} is safe to use 
in the context that expects~\jltype{S}.
For example, if class \jltype{Rectangle} is a subtype of \jltype{Shape},
an instance of \jltype{Rectangle} can be passed to a function
with an argument of type \jltype{Shape}.

In languages with nominal typing, subtyping can also be used for run-time
dispatch, in particular, \emph{multiple dynamic dispatch} 
(MDD)~\cite{bib:Chambers:1992:Cecil,bib:Clifton:2000:MultiJava}.
It allows a function to have several implementations 
for different types of arguments,
and the most suitable implementation for a particular call 
is picked dynamically, based on the run-time types of all arguments.
%and their subtyping relation to the function signatures.
For example, consider two implementations of addition,
\jlcode{+(Number, Number)} and \jlcode{+(String, String)},
and the call \jlcode{3+5}.
In this case, language run-time should pick 
the implementation for numbers 
because \jltype{Int $<:$ Number} but \jltype{Int $\not{<:}$ String}.

It is often convenient to think of subtyping \jltype{T $<:$ S}
in terms of the set inclusion: ``the elements of~\jltype{T} are the subset
of the elements of~\jltype{S}''~\cite{bib:Pierce:2002:TAPL}.
This intuition is not always correct, but there has been research on
the so-called \emph{semantic subtyping}~\cite{bib:Frisch:2008:sem-sub,
	bib:Castagna:2011:sem-sub, bib:Ancona:2016:sem-sub-oo} 
where subtyping is defined exactly as the subset relation. % on values.
Namely, types are given the set-theoretic interpretation
$\interpty{\ty} = \{\nu \Alt \vdash \nu : \ty \}$, 
and subtyping $\ty_1 <: \ty_2$ is defined 
as $\interpty{\ty_1} \subseteq \interpty{\ty_2}$.
In this way, a semantic definition of subtyping intertwines with 
a static typing relation.

However, subtyping does not always go together with static typing~---
it is also applicable in the context of \emph{dynamically} typed languages.
As mentioned before, subtyping can be used for multiple dynamic dispatch,
and MDD is rather widespread among dynamic languages, for instance,
Common Lisp, Julia, Clojure.
Such languages do not prevent type errors with static type checking
but detect them at run-time, by inspecting type tags associated with values.
Type tags are also used during dynamic dispatch: 
language run-time looks at the tags attached to the arguments
to find out their run-time types.

In this paper, we attempt to fill the gap between \emph{semantic subtyping} and 
\emph{dynamically} typed languages with \emph{nominal} typing.
Instead of directly interpreting types as sets of values,
we interpret them as sets of \emph{type tags} assuming 
each value is associated with a tag.
Our contributions are as follows:
\begin{enumerate}
  \item Tag-based semantic interpretation of types for a language
    with nominal types, tuples, and unions.
  \item Two syntactic definitions of subtyping, declarative and reductive,
    along with the Coq-mechanized proofs that the definitions are equivalent
    and coincide with the semantic interpretation. 	
  \item Proof of decidability of the reductive subtyping.
  \item Discussion of the implications of using semantic subtyping
    for multiple dynamic dispatch.
\end{enumerate}






