Subtyping is utilized by many static type systems.
Informally, a subtyping relation \jltype{T $<:$ S} states that
a value of type~\jltype{T} can be safely used
in the context that expects a value of type~\jltype{S}.
For example, if class \jltype{Rectangle} is a subtype of class \jltype{Shape},
than a function with an argument of type \jltype{Shape}
can be called with an instance of \jltype{Rectangle}. 

Subtyping can also be used for run-time dispatch of function calls, 
in particular, \emph{multiple dynamic dispatch} 
(MDD)~\cite{bib:Chambers:1992:Cecil,bib:Clifton:2000:MultiJava}.
It allows a function to have several implementations 
for different types of arguments,
and the most suitable implementation for a particular call 
is picked dynamically, based on the run-time types of all arguments.
%and their subtyping relation to the function signatures.
For example, consider two implementations of addition,
\jlcode{+(Number, Number)} and \jlcode{+(String, String)},
and the call \jlcode{3+5}.
In this case, a language run-time should pick 
the implementation for numbers 
because \jltype{Int $<:$ Number} but \jltype{Int $\not{<:}$ String}.

It is often convenient to think of subtyping \jltype{T $<:$ S}
in terms of the set inclusion: ``the elements of~\jltype{T} are a subset
of the elements of~\jltype{S}''~\cite{bib:Pierce:2002:TAPL}.
This intuition is not always correct, but in the case of
\emph{semantic subtyping}~\cite{bib:Hosoya:2003:XDuce,
  bib:Frisch:2008:sem-sub, bib:Ancona:2016:sem-sub-oo}, 
subtyping is defined exactly as the subset relation. % on values.
Namely, types are given the set-theoretic interpretation
$\interpty{\ty} = \{\nu \Alt \vdash \nu : \ty \}$, 
and subtyping $\ty_1 <: \ty_2$ is defined as inclusion 
of the interpretations
$\interpty{\ty_1} \subseteq \interpty{\ty_2}$.
In this way, the semantic definition of subtyping intertwines with 
a static typing relation.

However, subtyping is not limited to statically typed languages~---
it is also applicable in the context of \emph{dynamically} typed ones.
As mentioned before, subtyping can be used for multiple dynamic dispatch,
and MDD is rather widespread among dynamic languages
such as CLOS, Julia, Clojure.
Unlike statically typed languages, 
which conservatively prevent type errors with static checking,
dynamic languages detect type errors at run-time.
Namely, whenever an operator is restricted to certain kinds of values,
the language run-time checks the arguments of the operator before running it;
often, such a check amounts to checking the \emph{type tag} associated 
with the value argument.

A large number of dynamic languages provide support 
for object-oriented programming with classes, 
thus enabling user-defined hierarchies of nominal types,
which can be then used for dynamic dispatch.
Nominal types are the main source of type tags.
Often, there is a distinction between concrete 
and abstract classes/interfaces.
A concrete class can be instantiated, 
and its instances are tagged with the class name.
Abstract classes, on the other hand, do not have direct instances,
so they do not induce type tags.

In this paper, we are bridging the gap between \emph{semantic} subtyping 
and \emph{dynamically} typed languages with \emph{nominal} types.
Instead of directly interpreting types as sets of values,
we interpret them as sets of \emph{type tags} assuming 
each value is associated with a tag.
Our contributions are as follows:
\begin{enumerate}
  \item Tag-based semantic interpretation of types for a language
    with nominal types, tuples, and unions (\secref{sec:semsub}).
  \item Two syntactic definitions of subtyping, declarative and reductive,
    along with the Coq-mechanized proofs that the definitions are equivalent
    and coincide with the semantic interpretation (\secref{sec:synsub}). 	
  \item Proof of decidability of the reductive subtyping.
  \item Discussion of the implications of using semantic subtyping
    for multiple dynamic dispatch (\secref{sec:discussion}).
\end{enumerate}






