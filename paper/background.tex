A programming language is usually called \defemph{dynamically typed}
if no type checking is performed statically
but errors related to types \emph{are} raised at run-time.
For example, consider the simple code below, assuming that
multiplication \jlcode{(*)} is defined only on integers, 
string concatenation \jlcode{(++)}~--- only on strings,
and no implicit conversion between types is allowed.
\begin{verbatim}
    (x * 5) ++ "hello"
\end{verbatim}
%We assume that addition \jlcode{(+)} is defined only on integers, 
%string concatenation \jlcode{(\&\&)}~--- only on strings,
%and no implicit conversion between types is allowed.
In a dynamically typed language, two scenarios of running the code are possible
depending on the run-time value of \jlcode{x}.
(1) If \jlcode{x} contains a non-integer value $v$, 
the program raises a type error "$v$ is not an integer",
because multiplication expects integers for both arguments.
(2) If \jlcode{x} contains an integer,
evaluation of \jlcode{(x * 5)} succeeds and produces an integer $n$,
but then, the program raises a (different) type error, "$n$ is not a string", 
because concatenation expects string arguments.
Note that we only care about %in the case of dynamic typing,
types of \emph{values}. By contrast, in a statically typed language,
the static checker needs to reason about whole expressions and approximate
types of values they might produce.

We can add flexibility to our imaginary dynamically typed language
by the means of \defemph{multiple dynamic dispatch} (MDD), 
which we explain in a bit.
So far, we assumed that multiplication and concatenation are defined only
for integers and strings, respectively
(we use the Julia syntax for function definitions):
\begin{verbatim}
     *(x::Int, y::Int) = integer_mult(x, y)
    ++(a::Str, b::Str) = string_concat(a, b)
\end{verbatim}
MDD allows to have several \emph{distinct} definitions of the same function
(usually called methods), with function calls being \emph{dispatched} 
to the best method \emph{at run-time}.

Methods are considered distinct if they accept different sets 
of values as their arguments. For instance, the following concatenation 
method\footnote{Function \jlftcode{string} converts its argument to a string.} 
is distinct from the one we already have 
that expects strings for both arguments:
\begin{verbatim}
++(x::Int, s::Str) = string(x) ++ s
\end{verbatim}
With this method, scenario (2) of running the original example changes:
the call $n$\jlcode{ ++ "hello"} dispatches to the method
\jlcode{++(::Int, ::Str)}, which succeeds producing a string.
%Note that if we replace \jlcode{"hello"} with an integer, the program will fail
%again because neither of the concatenation methods accepts two integers.

Types used in method signatures can be more complex than 
just \jltype{Int} and \jltype{Str}. For example:
\begin{verbatim}
*(x::Real, y::Real) = 
    float_mult(float(x), float(y))
*(s::Str,  y::Union{Int,Flt}) = length(s) * y
\end{verbatim}
Here we assume that \jltype{Real} is an abstract nominal type, 
with both \jltype{Int} and \jltype{Flt} being its declared subtypes.
The first method above accepts any values that are real numbers
and converts them to floats. %, and calls float multiplication.
The second method accepts a string as the first argument, and either an integer
or a float as the second one (this is what the union type means).

It is important to note that function calls are resolved at run-time,
based on the \emph{values} provided as arguments.
A method is considered to be \emph{applicable} in a particular call
if value arguments are in the set accepted by the method.
If no methods are applicable, an error is raised.
If several methods are applicable and neither of them is better than
the others, an error is raised.

Method $m_1$ is considered to be ``better'', more specific than method $m_2$,
if $m_1$ accepts a smaller set of values than $m_2$.
For instance, in our examples, \jlcode{*(::Int, ::Int)} is more specific than
\jlcode{*(::Real, ::Real)} because the former accepts integers 
whereas the latter~--- any real numbers.
Naturally, this enables dispatching to integer multiplication 
for \jlcode{3 * 5} and float multiplication for \jlcode{3.14 * 5}, respectively.

Though the above explanation of MDD appeals to the set-theoretic reasoning,
in reality, languages have to use some syntactic rules to determine
applicable methods and compare them for specificity.
For instance, the Julia language uses \defemph{subtyping}.
For this, Julia looks at method signatures as well as function calls
as tuple types. For example, methods 
\jlcode{*(::Int, ::Int)} and \jlcode{*(::Real, ::Real)} are viewed as types
\jlcode{(Int, Int)} and \jlcode{(Real, Real)}, and calls 
\jlcode{3 * 5} and \jlcode{3.14 * 5}~--- as types
\jlcode{(Int, Int)} and \jlcode{(Flt, Int)}.
Then, the applicable methods are the ones that are supertypes of a call,
and the most specific method is the subtype of the other applicable methods.
In this paper, we present semantic and syntactic definitions of subtyping
for a subset of Julia types, and discuss the implications of the definitions
for multiple dynamic dispatch. Types of values are type tags.
