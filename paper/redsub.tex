\subsection{Reductive Subtyping}\label{sec:redsub}
%% -----------------------------------------------------------------------------

The declarative definition is not syntax-directed.
For one, it involves the \RD{Trans} rule, 
which requires ``coming up'' with an intermediate type $\ty_2$.
For instance, in order to show
\[\bjsub{\typair{\tystr}{\tyreal}}
{(\typair{\tystr}{\tyint}) \cup (\typair{\tystr}{\tystr}) 
	\cup (\typair{\tystr}{\tyflt})},\]
we need to apply transitivity several times, in particular, 
with the intermediate type $\typair{\tystr}{(\tyunion{\tyint}{\tyflt})}$.

\begin{figure}
	\begin{mathpar}
		\colorbox{light-gray}{$
		\inferrule*[right=SR-BaseRefl]
		{ }
		{ \bjsubr{\cname}{\cname} }
		$}
		\\
		
		\inferrule[SR-IntReal]
		{ }
		{ \bjsubr{\tyint}{\tyreal} }
		
		\inferrule[SR-FltReal]
		{ }
		{ \bjsubr{\tyflt}{\tyreal} }
		\\
	
		\inferrule[SR-CmplxNum]
		{ }
		{ \bjsubr{\tycmplx}{\tynum} }
		
		\colorbox{light-gray}{$
		\inferrule[SR-IntNum]
		{ }
		{ \bjsubr{\tyint}{\tynum} }
		$}
		
		\colorbox{light-gray}{$
		\inferrule[SR-FltNum]
		{ }
		{ \bjsubr{\tyflt}{\tynum} }
		$}
		\\
		
		\inferrule*[right=SR-Pair]
		{ \bjsubr{\ty_1}{\ty'_1} \\ \bjsubr{\ty_2}{\ty'_2} }
		{ \bjsubr{\typair{\ty_1}{\ty_2}}{\typair{\ty'_1}{\ty'_2}} }
		\\
		
		\inferrule*[right=SR-UnionL]
		{ \bjsubr{\ty_1}{\ty'} \\ \bjsubr{\ty_2}{\ty'} }
		{ \bjsubr{\tyunion{\ty_1}{\ty_2}}{\ty'} }
		\\
		
		\colorbox{light-gray}{$
		\inferrule[SR-UnionR1]
		{ \bjsubr{\ty}{\ty'_1} }
		{ \bjsubr{\ty}{\tyunion{\ty'_1}{\ty'_2}} }
		$}
		
		\colorbox{light-gray}{$
		\inferrule[SR-UnionR2]
		{ \bjsubr{\ty}{\ty'_2} }
		{ \bjsubr{\ty}{\tyunion{\ty'_1}{\ty'_2}} }
		$}
		\\
		
		\colorbox{light-gray}{$
		\inferrule*[right=SR-NF]
		{ \bjsubr{\NF(\ty)}{\ty'} }
		{ \bjsubr{\ty}{\ty'} }
		$}
	\end{mathpar}
	\caption{Reductive subtyping for \BetaJulia}
	\label{fig:bjsem-red-sub}
\end{figure}

The syntax-directed reductive definition\footnote{The definition
	%the rules can be easily turned 
	%into a subtyping algorithm.
	is not deterministic, though.	For example, there are two ways to derive 
	$\bjsubr{\typair{\tystr}{(\tyunion{\tyint}{\tyflt})}}
	{\typair{\tystr}{(\tyunion{\tyint}{\tyflt})}}$: 
	either by immediately applying \RR{Pair}, 
	or by first normalizing the left-hand side with \RR{NF}.} of subtyping
is presented in~\figref{fig:bjsem-red-sub}.
Some of the inductive rules have the exact declarative counterparts,
such as the rule for subtyping of pairs (\RR{Pair}) 
or the rule for a union on the left (\RR{UnionL}).
The differing rules are \colorbox{light-gray}{highlighted}.
The explicit reflexivity rule \RR{BaseRefl} now only works with 
concrete nominal types, which is enough for the definition to be reflexive.
General transitivity is gone as well; instead, it gets incorporated into
other rules, such as subtyping of nominal types (\RR{IntNum}, \RR{FltNum})
or subtyping of a union on the right (\RR{UnionR1}, \RR{UnionR2}).

The last rule of the definition, \RR{NF}, is the most important.
It rewrites type \ty into its \defemph{normal form} $\NF(\ty)$
before applying other subtyping rules.
This covers all useful applications of transitivity and distributivity 
that are possible in the declarative definition.
The normalized type has the form $\vty_1 \cup \vty_2 \cup \ldots \cup \vty_n$,
i.e. a union of value types
(we omit parenthesis because union is associative).
The normalization function $\NF$ is presented in~\figref{fig:bjsem-calc-nf}
(the auxiliary function $\unprs$ 
can be found in~\figref{fig:bjsem-calc-nf-full}, \appref{app:nf}).
It produces a type in \emph{disjunctive normal form}
by replacing an abstract nominal type 
with the union of all its concrete subtypes, 
a pair of unions with the union of pairs of value types
(each of this pairs is a value type),
for instance:
\[
\NF(\typair{\tystr}{(\tyunion{\tyint}{\tyflt})}) =
\tyunion{(\typair{\tystr}{\tyint})}{(\typair{\tystr}{\tyflt})}.
\]
As we show in~\secref{sec:declsub-correct}, a type and its normal form are
equivalent in the declarative definition, an essential property
for reductive subtyping being equivalent to declarative one.

\begin{figure}
  \[
	\begin{array}{rcl}
	\NF: \Type &\rightarrow& \Type \\
	\NF(\cname) &=& \cname \\
	\colorbox{light-gray}{\NF(\tyreal)} &=&
	\colorbox{light-gray}{\tyunion{\tyint}{\tyflt}} \\
	\colorbox{light-gray}{\NF(\tynum)} &=&
	\colorbox{light-gray}{\tyunion{\tyunion{\tyint}{\tyflt}}{\tycmplx}} \\
	\NF(\typair{\ty_1}{\ty_2}) &=& \unprs(\NF(\ty_1), \, \NF(\ty_2))	\\
	\NF(\tyunion{\ty_1}{\ty_2}) &=& \tyunion{\NF(\ty_1)}{\NF(\ty_2)} \\
	\end{array}
  \]
	\caption{Computing normal form of \BetaJulia types}
	\label{fig:bjsem-calc-nf}
\end{figure}


% for using the normal form (\RR{NF}).
%Note that the last rule also takes care of distributivity.

%With the reductive subtyping, the example above can be derived as follows:
%\begin{mathpar}\small
%\inferrule*[right=]
%{ \inferrule*[right=]
%  { \bjsub{\typair{\tystr}{\tyint}}{(\typair{\tystr}{\tyint}) \ldots} \\
%    \bjsub{\typair{\tystr}{\tyflt}}{\ldots (\typair{\tystr}{\tyflt})}  }	
%  { \bjsub{\tyunion{(\typair{\tystr}{\tyint})}{(\typair{\tystr}{\tyflt})}}
%	{(\typair{\tystr}{\tyint}) \cup \ldots \cup (\typair{\tystr}{\tyflt})} } }
%{ \bjsub{\typair{\tystr}{\tyreal}}
%	{(\typair{\tystr}{\tyint}) \cup (\typair{\tystr}{\tystr}) 
%		\cup (\typair{\tystr}{\tyflt})} }.
%\end{mathpar}
%In the very bottom, we use \RR{NF}, and then \RR{UnionL} in the level above.
%To complete the top of derivation, we would also need to use \RR{UnionR*}, 
%\RR{Pair}, and \RR{BaseRefl}.

