While the semantic approach does provides us with a useful intuition,
we need to be able to build the subtyping algorithm in order to use subtyping.
However, neither of the definitions~\eqref{eq:truesemsub-def}, \eqref{eq:semsub-def} 
can be directly computed because of the quantification $\forall \vty$.
Therefore, we provide another, \emph{syntactic} 
definition of subtyping, which is
equivalent to the semantic one and also straightforward to implement.

We do this in two steps. 
First, we give an inductive definition that is handy to reason about,
called \emph{declarative} subtyping. 
We prove it equivalent to the semantic subtyping using the syntactic model
discussed above.
Second, we provide a \emph{reductive}, syntax-directed definition of subtyping
and prove it equivalent to the declarative definition 
(and, hence, the semantic one as well).
We prove that the reductive subtyping is decidable, 
that is, for any two types $\ty_1$ and $\ty_2$,
it is possible to prove that $\ty_1$ either is a subtype of $\ty_2$ or is not.
Since the Coq-proof is constructive, it essentially gives an algorithm
to decide subtyping. However, it is also possible to devise the algorithm
as a straightforward recursive function.

\subsection{Declarative Subtyping}
%% -----------------------------------------------------------------------------

Declarative definition of subtyping is provided in~\figref{fig:bjsem-decl-sub}.
The definition is mostly comprised of the standard rules
of syntactic subtyping for unions and pairs.
Namely, reflexivity and transitivity (\RD{Refl} and \RD{Trans}), 
subtyping of pairs (\RD{Pairs}),
and subtyping of unions (\RD{UnionL}, \RD{UnionR1}, \RD{UnionR2}).
Though \RD{UnionR*} rules are seemingly very strict, 
transitivity allows us to derive judgments such as
$\bjsub{\tyint}{\tyunion{\tystr}{\tyreal}}$ via
$\bjsub{\tyint}{\tyreal}$ and $\bjsub{\tyreal}{\tyunion{\tystr}{\tyreal}}$.
Note that we do need the syntactic definition of subtyping
to be \emph{reflexive} and \emph{transitive}
because so is semantic subtyping, which is just the subset relation.

Semantic subtyping also forces us to add rules 
for distributing pairs over unions, \RD{Distr1} and \RD{Distr2}. 
For example, consider two types,
\tyunion{(\typair{\tystr}{\tyint})}{(\typair{\tystr}{\tyflt})}
and \typair{\tystr}{(\tyunion{\tyint}{\tyflt})}.
They have the same semantic interpretation~---
$\{\typair{\tystr}{\tyint}, \typair{\tystr}{\tyflt}\}$.
Therefore, we should be able to derive the equivalence of the types 
using the declarative definition,
i.e., the declarative subtyping should hold in both directions.
One direction is trivial:
\begin{mathpar}{\small
\inferrule*[right=]
{ \inferrule*[right=]
  { \bjsub{\tystr}{\tystr} \\ \bjsub{\tyint}{\tyunion{\tyint}{\tyflt}} }
  { \bjsub{\typair{\tystr}{\tyint}}
  	  {\typair{\tystr}{(\tyunion{\tyint}{\tyflt})}} } \\
  \inferrule*[right=]
  { \ldots }
  { \bjsub{\typair{\tystr}{\tyflt}}
  	  {\ldots} } }
{ \bjsub{\tyunion{(\typair{\tystr}{\tyint})}{(\typair{\tystr}{\tyflt})}}
	{\typair{\tystr}{(\tyunion{\tyint}{\tyflt})}} }.
}\end{mathpar}
But the other direction,  
\[
\bjsub{\typair{\tystr}{(\tyunion{\tyint}{\tyflt})}}
  {\tyunion{(\typair{\tystr}{\tyint})}{(\typair{\tystr}{\tyflt})}},
\]
cannot be derived without \RD{Distr2} rule: 
\typair{\tystr}{(\tyunion{\tyint}{\tyflt})} is 
not a subtype of either \typair{\tystr}{\tyint} or \typair{\tystr}{\tyflt},
so we cannot apply \RD{UnionR*} rules\footnote{Transitivity
  does not help in this case.}.

The most interesting part of the definition hides in subtyping of nominal types.
There are four obvious rules coming directly 
from the nominal hierarchy. For instance, \RD{RealNum} mirrors the fact 
that $\bjdeclsub{\tyreal}{\tynum} \in \NomH$.
%Using these rules, judgments such as $\bjsub{\tyint}{\tynum}$ 
%can be derived by transitivity.
But there are also new rules, \RD{RealUnion} and \RD{NumUnion},
(\colorbox{light-gray}{highlighted} in~\figref{fig:bjsem-decl-sub}),
which are dictated by the semantic subtyping.
For example, we need \RD{RealUnion} to prove the equivalence
of types \tyunion{\tyint}{\tyflt} and \tyreal, 
which have the same interpretation $\{\tyint, \tyflt\}$.

%Before we define an inductive declarative relation $\bjsub{\ty_1}{\ty_2}$.

%Besides, the ability to reason about types directly,
%without appealing to all their value subtypes.
%Therefore, we provide  definitions of subtyping
%in the form of inductive rule

\begin{figure}
	\begin{mathpar}
		\inferrule*[right=SD-Refl]
		{ }
		{ \bjsub{\ty}{\ty} }
		
		\inferrule*[right=SD-Trans]
		{ \bjsub{\ty_1}{\ty_2} \\ \bjsub{\ty_2}{\ty_3} }
		{ \bjsub{\ty_1}{\ty_3} }		
		\\
		
		\inferrule[SD-IntReal]
		{ }
		{ \bjsub{\tyint}{\tyreal} }
		
		\inferrule[SD-FltReal]
		{ }
		{ \bjsub{\tyflt}{\tyreal} }
		\\
		
		\inferrule[{SD-RealNum}]
		{ }
		{ \bjsub{\tyreal}{\tynum} }
	
		\inferrule[{SD-CmplxNum}]
		{ }
		{ \bjsub{\tycmplx}{\tynum} }
		\\
		
		\colorbox{light-gray}{$
		\inferrule[SD-RealUnion]
		{ }
		{ \bjsub{\tyreal}{\tyunion{\tyint}{\tyflt}} }
		$}
		
		\colorbox{light-gray}{$
		\inferrule[SD-NumUnion]
		{ }
		{ \bjsub{\tynum}{\tyunion{\tyreal}{\tycmplx}} }
		$}
		\\
		
		\inferrule*[right=SD-Pair]
		{ \bjsub{\ty_1}{\ty'_1} \\ \bjsub{\ty_2}{\ty'_2} }
		{ \bjsub{\typair{\ty_1}{\ty_2}}{\typair{\ty'_1}{\ty'_2}} }
		\\
		
		\inferrule*[right=SD-UnionL]
		{ \bjsub{\ty_1}{\ty'} \\ \bjsub{\ty_2}{\ty'} }
		{ \bjsub{\tyunion{\ty_1}{\ty_2}}{\ty'} }
		\\
		
		\inferrule[{SD-UnionR1}]
		{ }
		{ \bjsub{\ty_1}{\tyunion{\ty_1}{\ty_2}} }
		
		\inferrule[{SD-UnionR2}]
		{ }
		{ \bjsub{\ty_2}{\tyunion{\ty_1}{\ty_2}} }
		\\
		
		\inferrule*[right=SD-Distr1]
		{ }
		{ \bjsub{\typair{(\tyunion{\ty_{11}}{\ty_{12}})}{\ty_2}}
			{\tyunion{(\typair{\ty_{11}}{\ty_2})}{(\typair{\ty_{12}}{\ty_2})}} }
		
		\inferrule*[right=SD-Distr2]
		{ }
		{ \bjsub{\typair{\ty_1}{(\tyunion{\ty_{21}}{\ty_{22}})}}
			{\tyunion{(\typair{\ty_1}{\ty_{21}})}{(\typair{\ty_1}{\ty_{22}})}} }
	\end{mathpar}
	\caption{Declarative subtyping for \BetaJulia}
	\label{fig:bjsem-decl-sub}
\end{figure}


\subsection{Correctness of Declarative Subtyping}
%% -----------------------------------------------------------------------------

In order to show that the declarative subtyping is equivalent
to the semantic one,
we need to prove that the former is sound and complete with respect
to the latter one, that is:
\[
\forall \ty_1, \ty_2.\ (\bjsub{\ty_1}{\ty_2} \iff \bjtruesemsub{\ty_1}{\ty_2}).
\]
As discussed in~\secref{sec:syn-model-of-semsub}, 
the syntactic model $\bjsemsub{\ty_1}{\ty_2}$ is equivalent 
to the semantic subtyping.
So for proofs, we will be using the model.

\begin{theorem}[Correctness of Declarative Subtyping]\label{thm:declsub-correct}
\[
\forall \ty_1, \ty_2.\ (\bjsub{\ty_1}{\ty_2} \iff\ \bjsemsub{\ty_1}{\ty_2})
\]
\end{theorem}

In order to prove the theorem, we need several auxiliary observations.
Let us recall the definition of $\bjsemsub{\ty_1}{\ty_2}$:
\[
\bjsemsub{\ty_1}{\ty_2} \quad \defsign \quad
\forall \vty.\ (\bjmtch{\vty}{\ty_1} \implies\ \bjmtch{\vty}{\ty_2}).
\]
The first thing to note is that
subtyping a value type coincides with matching:
\begin{equation}\label{eq:mtch-eq-declsub}
\forall \vty, \ty.\ (\bjsub{\vty}{\ty} \iff\ \bjmtch{\vty}{\ty}).
\end{equation}
Having that, it is easy to prove the \emph{soundness} direction
of~\thmref{thm:declsub-correct}.
\begin{lemma}[Soundness of Declarative Subtyping]
\[
\forall \ty_1, \ty_2.\ 
[\bjsub{\ty_1}{\ty_2} \implies\ 
\forall \vty.\ (\bjmtch{\vty}{\ty_1} \implies\ \bjmtch{\vty}{\ty_2})]
\]
\end{lemma}
\noindent
\Proof. We know $\bjmtch{\vty}{\ty_1}$ and $\bjsub{\ty_1}{\ty_2}$.
We need to show that $\bjmtch{\vty}{\ty_2}$.
First, we apply~\eqref{eq:mtch-eq-declsub} to $\bjmtch{\vty}{\ty_1}$
and $\bjmtch{\vty}{\ty_2}$. 
Now it suffices to show that $\bjsub{\vty}{\ty_2}$ follows from
$\bjsub{\vty}{\ty_1}$ and $\bjsub{\ty_1}{\ty_2}$, 
which is trivially true by~\RD{Trans}.
\qed

\begin{lemma}[Completeness of Declarative Subtyping]\label{lem:declsub-complete}
\[	
\forall \ty_1, \ty_2.\ 
[\bjsemsub{\ty_1}{\ty_2} \implies\ \bjsub{\ty_1}{\ty_2}]
\]
\end{lemma}

This direction of~\thmref{thm:declsub-correct} is more challenging. 
The key observation here is that \lemref{lem:declsub-complete} can be shown for 
$\ty_1$ of the form $\vty_1 \cup \vty_2 \cup \ldots \cup \vty_n$
(we omit parenthesis because union is associative).
In this case, in the definition of $\bjsemsub{\ty_1}{\ty_2}$ the only
$\vty$s that match $\ty_1$ and $\ty_2$ are $\vty_i$. 
By~\eqref{eq:mtch-eq-declsub} we know that matching implies subtyping,
so we also have $\bjsub{\vty_i}{\ty_2}$.
From the latter, it is easy to show that $\bjsub{\ty_1}{\ty_2}$ because
$\ty_1$ is just a union of value types, 
and subtyping of the left-hand side union amounts to subtyping its components,
according to the \RD{UnionL} rule.

\paragraph{Normal Form}
We say that a type $\ty \equiv \vty_1 \cup \vty_2 \cup \ldots \cup \vty_n$
is in \defemph{normal form} and denote this fact by $\InNF(\ty)$ 
(formal definition of $\InNF$ is given 
in~\figref{fig:bjsem-innf}, \appref{app:nf}).
For each type \ty, there is an equivalent normalized type 
that can be computed with the function $\NF$
defined in~\figref{fig:bjsem-calc-nf} (the auxiliary function $\unprs$ 
can be found in~\figref{fig:bjsem-calc-nf-full}, \appref{app:nf}).
Note that abstract nominal types are unfolded into unions of all their
value subtypes. A pairs gets rewritten into a union of value pairs, 
thus producing a type in the disjunctive normal form.

Using the fact that every type can be normalized,
and that declarative subtyping is complete for normalized types, 
we can finally prove \lemref{lem:declsub-complete}.

\begin{lemma}[Properties of the Normal Form]\label{lem:declsub-nf}
\[
\forall \ty.\ [\InNF(\NF(\ty))\;\ \land\;
\bjsub{\ty}{\NF(\ty)}\;\ \land\; \bjsub{\NF(\ty)}{\ty}]
\]
\end{lemma}

\begin{lemma}[Completeness for Normalized Types]
\label{lem:nf-declsub-complete}
\[
	\forall \ty_1, \ty_2 \Alt \InNF(\ty_1).\
	[\bjsemsub{\ty_1}{\ty_2} \implies\ \bjsub{\ty_1}{\ty_2}]
\]
\end{lemma}

\begin{lemma}\label{lem:nf-semsub}
$
\forall \ty_1, \ty_2.\ 
[\bjsemsub{\ty_1}{\ty_2} \implies\ \bjsemsub{\NF(\ty_1)}{\ty_2}]
$
\end{lemma}

\begin{figure}
  \[
	\begin{array}{rcl}
	\NF: \Type &\rightarrow& \Type \\
	\NF(\cname) &=& \cname \\
	\colorbox{light-gray}{\NF(\tyreal)} &=&
	\colorbox{light-gray}{\tyunion{\tyint}{\tyflt}} \\
	\colorbox{light-gray}{\NF(\tynum)} &=&
	\colorbox{light-gray}{\tyunion{\tyunion{\tyint}{\tyflt}}{\tycmplx}} \\
	\NF(\typair{\ty_1}{\ty_2}) &=& \unprs(\NF(\ty_1), \, \NF(\ty_2))	\\
	\NF(\tyunion{\ty_1}{\ty_2}) &=& \tyunion{\NF(\ty_1)}{\NF(\ty_2)} \\
	\end{array}
  \]
	\caption{Computing normal form of \BetaJulia types}
	\label{fig:bjsem-calc-nf}
\end{figure}

\noindent
\Proof (Lemma~\ref{lem:declsub-complete}).
We know $\bjsemsub{\ty_1}{\ty_2}$, and we need to show $\bjsub{\ty_1}{\ty_2}$.
First, we apply \lemref{lem:nf-semsub} to $\bjsemsub{\ty_1}{\ty_2}$,
and then \lemref{lem:nf-declsub-complete},
this gives us $\bjsub{\NF(\ty_1)}{\ty_2}$.
Using \lemref{lem:declsub-nf} and \RD{Trans}, we can show
$\bjsub{\ty_1}{\ty_2}$.
\qed