
We build the presentation around a small type language called \BetaJulia,
presented in~\figref{fig:bjsem-types}.
Types of \BetaJulia, denoted by $\ty \in \Type$, include pairs, unions, 
and nominal types in the spirit of Julia:
\cname denotes \emph{concrete} nominal types that correspond to type tags,
and \aname denotes \emph{abstract} nominal types.
In this terminology, \jltype{Int64} and \jltype{Signed} are
a concrete and abstract type, respectively.\footnote{Correspondence to Julia.}

\begin{figure}
  \[
	\begin{array}{rcl@{\qquad}l}
	\ty \in \Type & ::= & & \text{\emph{Types}}
	\\ &\Alt& \typair{\ty_1}{\ty_2}  & \text{covariant pair}
	\\ &\Alt& \tyunion{\ty_1}{\ty_2} & \text{untagged union}
	\\ &\Alt& \cname  & \text{concrete nominal type}
	\\ &\Alt& \aname  & \text{abstract nominal type}
	\\ \\
	\cname & \in &
	  \multicolumn{2}{l}{\{ \tyint, \tyflt, \tycmplx, \tystr \}}
	\\ 
	\aname & \in & \multicolumn{2}{l}{\{ \tyreal, \tynum \}}
	\end{array}
  \]
  \begin{tikzpicture}[sibling distance=4em, level distance=2.25em,
    concrete/.style = {shape=rectangle, draw, align=center}]
  \node { Num }
  child { node { Real }
  	child { node[concrete] { Int} }
  	child { node[concrete] (NF) { Flt} } }
  child { node[concrete, right=2em of NF] (NC) {Cmplx} }
  ;
  \node[concrete, right=2em of NC] {Str} ;
  \end{tikzpicture}
  \caption{\BetaJulia: type grammar and nominal hierarchy}
  \label{fig:bjsem-types}
\end{figure}

To simplify the development, we decided to work with particular 
nominal types and a hierarchy over them
(presented in~\figref{fig:bjsem-types} as a tree)
instead of a more abstract class table.
There are four concrete, leaf types (depicted in rectangles)
and two abstract types in the hierarchy. 
Formally, the hierarchy can be represented with a list of declarations
$\bjdeclsub{n_1}{n_2}$ read as ``$n_1$ is a declared subtype of $n_2$''
where $n ::= \cname \Alt \aname$.
In the case of \BetaJulia, the hierarchy is defined as follows:
\[
\NomH = [ \bjdeclsub{\tyreal}{\tynum}, 
\bjdeclsub{\tyint}{\tyreal}, \bjdeclsub{\tyflt}{\tyreal},
\bjdeclsub{\tycmplx}{\tynum} ].
\]
\TODO{requirements for hierarchy, like single parent, no cycles}

\subsection{Value Types}
%% -----------------------------------------------------------------------------

Not only concrete nominal types can be used as type tags
but also pair types. For example, \typair{\tyint}{\tyint}
or \typair{\tystr}{(\typair{\tyint}{\tyint})}.
Union types, on the other hand, cannot be type tags, 
as they potentially describe dissimilar values.
For instance, both integer and floating point values belong
to a union type \tyunion{\tyint}{\tyflt}.
Even type \tyunion{\tyint}{\tyint} is not a type tag, 
though it better be equivalent to a concrete type \tyint.

Types that can be used as type tags will be further referred to
as \defemph{value types}. 
Their formal definition is given in~\figref{fig:bjsem-value-types}:
value type $\vty \in \VType$ is either a concrete nominal type 
or a pair of value types. 
Note that $\VType \subset \Type$, i.e. each value type is a type.

\begin{figure}
	\[
	\begin{array}{rcl@{\qquad}l}
	\vty \in \VType & ::= & & \text{\emph{Value Types}}
	\\ &\Alt& \cname & \text{concrete nominal type}
	\\ &\Alt& \typair{\vty_1}{\vty_2} & \text{pair of value types}
	\end{array}
	\]
	\caption{Value types in \BetaJulia}
	\label{fig:bjsem-value-types}
\end{figure}


\subsection{Semantic Interpretation of Types}
%% -----------------------------------------------------------------------------

As mentioned earlier, the set of values represented by a value type \vty
is unambiguously characterized by~\vty itself
as long as each run-time value is tagged with a value type.
But what about an arbitrary type?

First, let us consider an abstract nominal type, e.g. \tynum. 
According to the nominal hierarchy, \tynum value 
is either a concrete complex number, or a real number, which, in turn,
is either a concrete integer or a floating point number.
Therefore, the set of values represented by \tynum 
is described by the set of value types $\{\tycmplx, \tyint, \tyflt\}$.

Next, pairs. Consider type \typair{\tystr}{\tyreal}:
each of its values is a pair of a string and a number. 
For example, \jlcode{("bread", 2)} and \jlcode{("milk", 2.75)} are such values, 
with type tags \typair{\tystr}{\tyint} and 
\typair{\tystr}{\tyflt}, respectively.

\begin{figure}
  \[
	\begin{array}{rcl}
	\interpty{\cdot}: \Type &\rightarrow& \PVType \\
	\interpty{\cname}  & = & \{\cname\} \\
	\interpty{\tyreal} & = & \{ \tyint, \tyflt \} \\
	\interpty{\tynum} & = & \{ \tyint, \tyflt, \tycmplx \} \\
	\interpty{\typair{\ty_1}{\ty_2}} & = & \{\typair{\vty_1}{\vty_2} 
	\Alt \vty_1 \in \interpty{\ty_1}, \vty_2 \in \interpty{\ty_2}\}\\
	\interpty{\tyunion{\ty_1}{\ty_2}} & = & 
	\interpty{\ty_1} \cup \interpty{\ty_2}
	\end{array}
  \]
%  	\interpty{\aname} & = & \{\cname\ \Alt \bjnomsub{\cname}{\aname} \} \\
%  (= \interpty{\tyreal} \cup \{\tycmplx\})
  \caption{Semantic Interpretation of \BetaJulia Types}
  \label{fig:bjsem-interpretation}
\end{figure}

Formally, the \emph{interpretation} of \BetaJulia types is defined
in~\figref{fig:bjsem-interpretation}.
Abstract types are interpreted according to the nominal hierarchy:
values of each abstract type are values of any of it value subtypes.
More generally, the interpretation of abstract types can be given in
then following way:
\[
\interpty{\aname} = \{\cname\ \Alt \bjnomsub{\cname}{\aname} \},
\]
where the relation $\bjnomsub{n_1}{n_2}$,
read ``$n_1$ is a nominal subtype of~$n_2$'',
is a transitive closure of $\bjdeclsub{n_1}{n_2}$:
\begin{mathpar}
	\inferrule*[right=]
	{ \bjdeclsub{n_1}{n_2} \in \NomH }
	{ \bjnomsub{n_1}{n_2} }
	
	\inferrule*[right=]
	{ \bjnomsub{n_1}{n_2} \\ \bjnomsub{n_2}{n_3} }
	{ \bjnomsub{n_1}{n_3} }.
\end{mathpar}
\TODO{Probably more on the semantic interpretation.}

Once we have the interpretation of types, we define \emph{semantic subtyping}
as the subset relation:
\[
\bjtruesemsub{\ty_1}{\ty_2} \quad \defsign \quad
\interpty{\ty_1} \subseteq \interpty{\ty_2}.
\]

%and the set of values represented by a type \ty can be characterized
%with the set of value types~$\vty_i$
